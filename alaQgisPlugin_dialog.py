
import os
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from PyQt5.QtCore import Qt
from PyQt5 import QtCore
from PyQt5.QtWidgets import QApplication
from .checkableSearchableComboBox import CheckableComboBox

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'alaQgisPlugin_dialog_base.ui'))

# Set default combo box
COMBOBOX_ALL_LABEL = "-- All --"

class AlaQgisPluginDialog(QtWidgets.QDialog, FORM_CLASS):
    """
    /***************************************************************************
     AlaQgisPluginDialog
                                     A QGIS plugin
     This plugin is desiged to get ALA data into QGIS
     Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                                 -------------------
             begin                : 2025-10-01
             git sha              : $Format:%H$
             copyright            : (C) 2025 by Atlas of Living Australia
             email                : amanda.buyan@csiro.au
     ***************************************************************************/

    /***************************************************************************
     *                                                                         *
     *   This program is free software; you can redistribute it and/or modify  *
     *   it under the terms of the GNU General Public License as published by  *
     *   the Free Software Foundation; either version 2 of the License, or     *
     *   (at your option) any later version.                                   *
     *                                                                         *
     ***************************************************************************/
    """
    def __init__(self, parent=None):
        """
        Initialise the plugin
        """
        super(AlaQgisPluginDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        # populate predefined values
        self._populate_reasons()
        self._populate_data_profiles()
        self._populate_data_providers()
        self._populate_other_data_fields()

    """
    /***************************************************************************
     Variable Declaration
     ***************************************************************************/

    /***************************************************************************
     * Predefined values for the plugin, either statically or dynamically      *
     * defined.                                                                *
     *                                                                         *
     * Static Dictionaries:                                                    *
     *                                                                         *
     *   basisOfRecord                                                         *
     *       Describes how observations are made                               *
     *   threatenedLists                                                       *
     *       Authoritative lists of threatened species available in the ALA    *
     *   sensitiveLists                                                        *
     *       Authoritative lists of sensitive species available in the ALA     *
     *   migratoryLists                                                        *
     *       Authoritative lists of migratory species available in the ALA     *
     *   nonNativeLists                                                        *
     *       Authoritative lists of non-Native species available in the ALA    *
     *                                                                         *
     * Dynamic Dictionaries:                                                   *
     *                                                                         *
     *   dataProvidersList                                                     *
     *       List of all data providers in the ALA                             *
     *   otherDataFields                                                       *
     *       List of all other data fields available to download in the ALA    *
     *   dataProfiles                                                          *
     *       List of existing data profiles to fitler your query  in the ALA   *
     *   reasons                                                               *
     *       List of all reasons for downloading data in the ALA               *
     *                                                                         *
     ***************************************************************************/
    """

    """
    /*****************
     Combo box values
     *****************/
    """
    basisOfRecord = {
        COMBOBOX_ALL_LABEL: None,
        'Fossil specimen': 'FOSSIL_SPECIMEN',
        'Human observation': 'HUMAN_OBSERVATION',
        'Machine observation': 'MACHINE_OBSERVATION',
        'Material citation': 'MATERIAL_CITATION',       
        'Material sample': 'MATERIAL_SAMPLE',
        'Living specimen': 'LIVING_SPECIMEN',
        'Observation': 'OBSERVATION',       
        'Occurrence': 'OCCURRENCE',
        'Preserved specimen': 'PRESERVED_SPECIMEN',
    }

    # TODO: get data profiles from galah-python and put them into a dict
    dataProfiles = {
        COMBOBOX_ALL_LABEL: None,
        'ALA General': 'ALA',
        'Species Distribution Modelling (CSDM)': 'CSDM',
        'Data licensed for all uses': 're-usable',
        'Australian Virtual Herbarium': 'AVH'
    }

    # TODO: get data profiles from galah-python and put them into a dict
    reasons = {
        COMBOBOX_ALL_LABEL: None,
        'Conservation Management/Planning': 0,
        'Biosecurity Management/Planning': 1,
        'Environmental Assessment': 2,
        'Education': 3,
        'Scientific Research': 4,
        'Collection Management': 5,
        'Other': 6,
        'Ecological Research': 7,
        'Systematic Research/Taxonomy': 8,
        'Other Scientific Research': 9,
        'Testing': 10,
        'Citizen Science': 11,
        'Restoration/Remediation': 12,
        'Species Modelling': 13,
    }

    """
    /*****************
     Tick box values
     *****************/
    """
    threatenedLists = {
        'ACT': 'dr649',
        'EPBC': 'dr656',
        'NSW': 'dr650',
        'NT': 'dr651',
        'QLD': 'dr652',
        'SA': 'dr653',
        'TAS': 'dr654',
        'VIC': 'dr655',
        'WA': 'dr2201'
    }

    sensitiveLists = {
        'ACT': 'dr2627',
        'NSW': 'dr487',
        'NT': 'dr492',
        'QLD': 'dr493',
        'SA': 'dr884',
        'TAS': 'dr491',
        'VIC': 'dr490',
        'WA': 'dr467'
    }
    
    migratoryLists = {
        'Bonn': 'dr18987',
        'CAMBA': 'dr18989',
        'JAMBA': 'dr18988',
        'ROKAMBA': 'dr18990'
    }

    nonNativeLists = {
        'NonNative All': 'dr32213'
    }

    # change these to be more dynamic
    # TODO: get data profiles from galah-python and put them into a dict
    dataProvidersList = ['Australian Capital Territory','Northern Territory','South Australia']
    otherDataFields = ['basisOfRecord','country','stateProvince','locality']

    """
    /***************************************************************************
     Populating predefined values
     ***************************************************************************/

    /***************************************************************************
     * all of these functions will populate predefined values, which are       *
     * defined above.                                                          *
     *                                                                         *
     *   _populate_data_profiles:                                              *
     *       set default combo box values from variable `dataProfiles`         *
     *   _populate_data_providers:                                             *
     *       set default combo box values from variable `dataProvidersList`    *
     *   _populate_other_data_fields:                                          *
     *       set default combo box values from variable `otherDataFields`      *
     *   _populate_reasons:                                                    *
     *       set default combo box values from variable `reasons`              *
     *                                                                         *
     ***************************************************************************/
    """
       
    def _populate_data_profiles(self):
        vals = list(self.dataProfiles.keys())
        self.dataProfileComboBox.addItems(sorted(vals))

    # TODO: Test this
    def _populate_data_providers(self):
        n=1
        # dropdown
        # self.dataProvidersComboBox = CheckableComboBox(self.dataProvidersComboBox,position=(30,50)) # unsure about this
        # self.dataProvidersCheckableComboBox.toolButton = QtWidgets.QToolButton(self)
        # self.dataProvidersCheckableComboBox.toolButton.setText('Data Providers') # maybe take this out
        # self.dataProvidersCheckableComboBox.toolMenu = QtWidgets.QMenu(self)
        # for i,it in enumerate(self.dataProvidersList):
        #     self.dataProvidersCheckableComboBox.addItem(it)
        #     item = self.dataProvidersCheckableComboBox.model().item(i, 0)
        #     item.setCheckState(QtCore.Qt.Unchecked)
        #     action = self.dataProvidersCheckableComboBox.toolMenu.addAction(it) # unsure
        #     action.setCheckable(True)
        # self.dataProvidersCheckableComboBox.toolButton.setMenu(self.dataProvidersCheckableComboBox.toolMenu)
        # self.dataProvidersCheckableComboBox.toolButton.setPopupMode(QtWidgets.QToolButton.InstantPopup)

    # TODO: Test this
    def _populate_other_data_fields(self):
        n=1
        # completer = QtWidgets.QCompleter(self.otherDataFields)
        # completer.setCaseSensitivity(Qt.CaseInsensitive)
        # self.searchAddDataFieldsLineEdit.setCompleter(completer)
        # add check boxes here

    def _populate_reasons(self):
        vals = list(self.reasons.keys())
        self.reasonsComboBox.addItems(sorted(vals))

    """
    /***************************************************************************
     Functions for getting data from the UI
     ***************************************************************************/

    /***************************************************************************
     * all of these functions will parse input data from the UI.               *
     *                                                                         *
     *   parse_authoritative_lists:                                            *
     *       set default combo box values from variable `otherDataFields`      *
     *   parse_data_providers:                                                 *
     *       set default combo box values from variable `dataProfiles`         *
     *   parse_datetime:                                                       *
     *       set default combo box values from variable `dataProvidersList`    *
     *   parse_reason:                                                         *
     *       set default combo box values from variable `reasons`              *
     *   parse_spatial:                                                        *
     *       set default combo box values from variable `reasons`              *
     *   parse_spatial:                                                        *
     *       set default combo box values from variable `reasons`              *
     *   parse_spatial:                                                        *
     *       set default combo box values from variable `reasons`              *
     *   parse_spatial:                                                        *
     *       set default combo box values from variable `reasons`              *
     *   parse_spatial:                                                        *
     *       set default combo box values from variable `reasons`              *
     *                                                                         *
     ***************************************************************************/
    """
    def mint_doi(self):
        if self.createDoiCheckBox.isChecked():
            return True

    def parse_authoritative_lists(self):

        # initialise lists variable
        lists = []

        # Threatened Lists
        if self.actThreatCheckBox.isChecked():
            lists.append(self.threatenedLists['ACT'])
        if self.epbcThreatCheckBox.isChecked():
            lists.append(self.threatenedLists['EPBC'])
        if self.nswThreatCheckBox.isChecked():
            lists.append(self.threatenedLists['NSW'])
        if self.ntThreatCheckBox.isChecked():
            lists.append(self.threatenedLists['NT'])
        if self.qldThreatCheckBox.isChecked():
            lists.append(self.threatenedLists['QLD'])
        if self.saThreatCheckBox.isChecked():
            lists.append(self.threatenedLists['SA'])
        if self.tasThreatCheckBox.isChecked():
            lists.append(self.threatenedLists['TAS'])
        if self.vicThreatCheckBox.isChecked():
            lists.append(self.threatenedLists['VIC'])
        if self.waThreatCheckBox.isChecked():
            lists.append(self.threatenedLists['WA'])

        # Sensitive Lists
        if self.actSensCheckBox.isChecked():
            lists.append(self.sensitiveLists['ACT'])
        if self.nswSensCheckBox.isChecked():
            lists.append(self.sensitiveLists['NSW'])
        if self.ntSensCheckBox.isChecked():
            lists.append(self.sensitiveLists['NT'])
        if self.qldSensCheckBox.isChecked():
            lists.append(self.sensitiveLists['QLD'])
        if self.saSensCheckBox.isChecked():
            lists.append(self.sensitiveLists['SA'])
        if self.tasSensCheckBox.isChecked():
            lists.append(self.sensitiveLists['TAS'])
        if self.vicSensCheckBox.isChecked():
            lists.append(self.sensitiveLists['VIC'])
        if self.waSensCheckBox.isChecked():
            lists.append(self.sensitiveLists['WA'])

        # Migratory Lists
        if self.bonnMigratoryCheckBox.isChecked():
            lists.append(self.migratoryLists['Bonn'])
        if self.cambaCheckBox.isChecked():
            lists.append(self.migratoryLists['CAMBA'])
        if self.jambaCheckBox.isChecked():
            lists.append(self.migratoryLists['JAMBA'])
        if self.rokambaCheckBox.isChecked():
            lists.append(self.migratoryLists['ROKAMBA'])

        # Non-Native Lists
        if self.nonNativeCheckBox.isChecked():
            lists.append(self.nonNativeLists['NonNative All'])

        # create appropriate filters for this and return as string
        if len(lists) > 0:
            return 'species_list_uid={}'.format(','.join(lists))
        else:
            return None

    def parse_basis_of_record(self):

        # declare list of potential values
        bor = []

        # check to see if any/all boxes are check
        if self.fossilSpecimenCheckBox.isChecked():
            bor.append(self.basisOfRecord['Fossil specimen'])
        if self.humanObservationCheckBox.isChecked():
            bor.append(self.basisOfRecord['Human observation'])
        if self.machineObservationCheckBox.isChecked():
            bor.append(self.basisOfRecord['Machine observation'])
        if self.materialCitationCheckBox.isChecked():
            bor.append(self.basisOfRecord['Material Citation'])
        if self.materialSampleCheckBox.isChecked():
            bor.append(self.basisOfRecord['Material sample'])
        if self.livingSpecimenCheckBox.isChecked():
            bor.append(self.basisOfRecord['Living specimen'])
        if self.observationCheckBox.isChecked():
            bor.append(self.basisOfRecord['Observation'])
        if self.occurrenceCheckBox.isChecked():
            bor.append(self.basisOfRecord['Occurrence'])       
        if self.preservedSpecimenCheckBox.isChecked():
            bor.append(self.basisOfRecord['Preserved specimen'])

        # create appropriate filters for this and return as string
        if len(bor) > 0:
            return 'basisOfRecord={}'.format(','.join(bor))
        else:
            return None

    def parse_data_fields(self):
        return ['basic']

    def parse_data_profile(self):
        for p in self.dataProfiles:
            if self.dataProfileComboBox == p:
                return self.dataProfiles[p]

    # TODO: write and test that this works
    def parse_data_providers(self):
        dataProviders = [] #self.collectionCodeField.text()
        if len(dataProviders) > 0:
            return 'dataProviderName={}'.format(','.join(dataProviders))
        else:
            return ModuleNotFoundError    

    # TODO: write and test that this works
    def parse_datetime(self):
        startDate = self.startDateEdit.text()
        endDate = self.startDateEdit.text()
        return None
        # if len(datetimes) > 0:
        #     return 'eventDate={}'.format(','.join(datetimes))
        # else:
        #     return ''  

    def parse_doi_as_query(self):
        doi = self.doiLineEdit.text()
        if doi is not None:
            return doi
        return None

    def parse_email(self):
        return self.emailLineEdit.text()

    def parse_present_absent(self):

        # initialise status list
        status = []

        # check if present/absent boxes are ticked
        if self.absentCheckBox.isChecked():
            status.append('ABSENT')
        if self.humanObservationCheckBox.isChecked():
            status.append('PRESENT')

        # create appropriate filters for this and return as string
        if len(status) > 0:
            return 'occurrenceStatus={}'.format(','.join(status))
        else:
            return None

    # TODO: write and test that this works
    def parse_reason(self):
        for r in self.reasons:
            if self.reasonsComboBox == r:
                return self.reasons[r]

    # TODO: write and test that this works
    def parse_spatial(self):
        return None
        # spatial_layers = []
        # if len(spatial_layers) > 0:
        #     return 'X={}'.format(','.join(spatial_layers))
        # else:
        #     return ''  
    
    def parse_taxonomy(self):
        return None

    """
    /***************************************************************************
     Buttons
     ***************************************************************************/

    /***************************************************************************
     * All these functions connect buttons to their relevant functions.        *
     *                                                                         *
     *   _populate_data_profiles:                                              *
     *       set default combo box values from variable `dataProfiles`         *
     *   _populate_data_providers:                                             *
     *       set default combo box values from variable `dataProvidersList`    *
     *   _populate_other_data_fields:                                          *
     *       set default combo box values from variable `otherDataFields`      *
     *   _populate_reasons:                                                    *
     *       set default combo box values from variable `reasons`              *
     *                                                                         *
     ***************************************************************************/
    """

    def upload_species_list_button(self):
        self.uploadSpeciesListPushButton.clicked.connect(self.upload_species_list())
    
    def draw_bounding_box_button(self):
        n=1

    def upload_shapefile_button(self):
        n=1

    def add_buffer_button(self):
        n=1

    def check_num_occurrences_button(self):
        self.checkNumOccurrences.clicked.connect(self.check_num_occurrences())

    def get_species_list_count_status_button(self):
        self.speciesListCountsStatuses.clicked.connect(self.get_species_list_counts_statuses())

    def get_download_occurrences_button(self):
        self.occDownload.clicked.connect(self.download_occurrences())

    """
    /***************************************************************************
     Query Data
     ***************************************************************************/

    /***************************************************************************
     * all of these functions will get input data from the UI.                 *
     *                                                                         *
     *   _populate_data_profiles:                                              *
     *       set default combo box values from variable `dataProfiles`         *
     *   _populate_data_providers:                                             *
     *       set default combo box values from variable `dataProvidersList`    *
     *   _populate_other_data_fields:                                          *
     *       set default combo box values from variable `otherDataFields`      *
     *   _populate_reasons:                                                    *
     *       set default combo box values from variable `reasons`              *
     *                                                                         *
     ***************************************************************************/
    """

    def parse_filters(self):
        '''
        def _ui_to_filters(self):
            return {'scientificName': self.scientificNameField.text(),
                'basisOfRecord': self.basisOfRecord[self.basisComboBox.currentText()],
                'country': _get_selected_country_code(self.countryComboBox),
                'catalogNumber': self.catalogNumberField.text(),
                'publishingCountry': _get_selected_country_code(self.publishingCountryComboBox),
                'institutionCode': self.institutionCodeField.text(),
                'collectionCode': self.collectionCodeField.text(),
                'year': _get_val_or_range(self.yearRangeBox, self.minYearEdit, self.maxYearEdit),
                'taxonKey': self.taxonKeyField.text(),
                'datasetKey': self.datasetKeyField.text(),
                'recordedBy': self.recordedByField.text(),
                'gadm_gid': self.gadmGidField.text()} 
        '''
        filters = []
        checkbox_filters = self.parse_authoritative_lists()
        datetime_filters = self.parse_datetime()
        spatial_filters = self.parse_spatial()
        data_providers = self.parse_data_providers()
        for fs in [checkbox_filters,datetime_filters,spatial_filters,data_providers]:
            if fs is not None:
                filters.append(fs)
        return filters

    # def parse_taxonomy(self):
    #     return {
    #         'scientificName': self.speciesLineEdit.text(),
    #         'kingdom': self.kingdomLineEdit.text(),
    #         'phylum': self.phylumLineEdit.text(),
    #         'class': self.classLineEdit.text(),
    #         'order': self.orderLineEdit.text(),
    #         'family': self.familyLineEdit.text(),
    #         'genus': self.genusLineEdit.text(),
    #         'vernacularName': self.commonNameLineEdit.text(),
    #         # 'species': self.speciesLineEdit.text(),
    #     }

    def parse_bounding_box(self):
        n=1

    """
    /***************************************************************************
     Button actions (not galah-python functions)
     ***************************************************************************/

    /***************************************************************************
     * all of these functions will get input data from the UI.                 *
     *                                                                         *
     *   _populate_data_profiles:                                              *
     *       set default combo box values from variable `dataProfiles`         *
     *   _populate_data_providers:                                             *
     *       set default combo box values from variable `dataProvidersList`    *
     *   _populate_other_data_fields:                                          *
     *       set default combo box values from variable `otherDataFields`      *
     *   _populate_reasons:                                                    *
     *       set default combo box values from variable `reasons`              *
     *                                                                         *
     ***************************************************************************/
    """

    def upload_species_list(self):
        '''
        TODO: test that this works
        '''
        dialog = QtWidgets.QFileDialog()
        dialog.setFileMode(QtWidgets.QFileDialog.AnyFile)
        dialog.setFilter(QtWidgets.QDir.Files)

        if dialog.exec_():
            file_name = dialog.selectedFiles()
            
            if file_name[0].endswith('.csv'):
                with open(file_name[0], 'r') as f:
                    data = f.read()
                    self.textEditor.setPlainText(data)
                    f.close()
            else:
                pass

    def add_buffer(self):
        n=1

    """
    /***************************************************************************
     galah-python query functions
     ***************************************************************************/

    /***************************************************************************
     * all of these functions will get input data from the UI.                 *
     *                                                                         *
     *   _populate_data_profiles:                                              *
     *       set default combo box values from variable `dataProfiles`         *
     *   _populate_data_providers:                                             *
     *       set default combo box values from variable `dataProvidersList`    *
     *   _populate_other_data_fields:                                          *
     *       set default combo box values from variable `otherDataFields`      *
     *   _populate_reasons:                                                    *
     *       set default combo box values from variable `reasons`              *
     *                                                                         *
     ***************************************************************************/
    """
    def check_ala_backbone(self):
        return None
        # taxonomy_dict = self.parse_taxonomy()
        # higher_taxa = {x: taxonomy_dict[x] for x in ['kingdom','phylum','class','order','family','genus']}
        # higher_taxa_none = all(higher_taxa[x] is None for x in higher_taxa.keys())
        # if self.speciesLineEdit.text() is not None and higher_taxa_none:
        #     # return galah.search_taxa(taxa=[self.speciesLineEdit.text()])
        #     n=1
        # elif self.speciesLineEdit.text() is not None and not higher_taxa_none:
        #     n=1
        #     # return galah.search_taxa(scientific_name=higher_taxa)
        # elif self.speciesLineEdit.text() is None and not higher_taxa_none:
        #     if sum([higher_taxa[x] is None for x in higher_taxa.keys()]) > 1:
        #         # return galah.search_taxa(scientific_name=higher_taxa)
        #         n=1
        #     else:
        #         name = next(v for k, v in higher_taxa.items() if v)
        #         # return galah.search_taxa(taxa=name)
        # else:
        #     return None

    def check_num_occurrences(self):
        n=1

    def get_species_list_counts_statuses(self):
        n=1

    def download_occurrences(self):
        email = self.parse_email()
        reason = self.parse_reason()
        data_profile = self.parse_data_profile()
        mint_doi = self.mint_doi()

        # TODO: enable button ONLY IF both are present
        if email is None: 
            raise ValueError('You need to provide an email to download occurrences')
        
        if reason is None:
            raise ValueError('')
        
        # put taxonomy stuff here
        #taxonomy = self.parse_taxonomy()
        
        # get other parameters
        filters = self.parse_filters()
        fields = self.parse_data_fields()

        # spatial_stuff = self.parse_spatial()
        
        '''
        galah.galah_config(email=email,reason=reason)
        galah.atlas_occurrences(taxa=taxonomy,filters=filters,mint_doi=mint_doi,fields=fields,
                                use_data_profile=data_profile,polygon=polygon,bbox=bbox)
        '''

'''
graveyard

    def _disable_controls(self):
        for widget in self.to_disable_during_load:
            widget.setDisabled(True)

    def _enable_controls(self):
        for widget in self.to_disable_during_load:
            widget.setDisabled(False)

        bor_values = galah.show_values(field='basisOfRecord')
        for i,row in bor_values.iterrows():
            text_value = bor_values['category'][i].lower().capitalize().replace('_',' ')
            basisOfRecord[text_value] = bor_values['category'][i]
'''